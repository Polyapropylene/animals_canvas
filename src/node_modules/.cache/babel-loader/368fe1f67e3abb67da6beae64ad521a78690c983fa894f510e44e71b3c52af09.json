{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n/* eslint-disable no-continue */\nimport throttle from 'lodash.throttle';\nimport { useRef, useEffect, useCallback, useMemo, useLayoutEffect, useState } from 'react';\nimport { useDebouncedFunction } from '../../hooks';\nimport { scrollToPos, getCalculatedPos, getCalculatedOffset, getItemSlot, getCarouselItems, translateToIndex } from './utils';\nvar THROTTLE_DEFAULT_MS = 100;\nvar DEBOUNCE_DEFAULT_MS = 150;\nexport var useCarousel = function useCarousel(_ref) {\n  var index = _ref.index,\n    axis = _ref.axis,\n    _ref$detectActive = _ref.detectActive,\n    detectActive = _ref$detectActive === void 0 ? false : _ref$detectActive,\n    _ref$detectThreshold = _ref.detectThreshold,\n    detectThreshold = _ref$detectThreshold === void 0 ? 0.5 : _ref$detectThreshold,\n    _ref$scrollAlign = _ref.scrollAlign,\n    scrollAlign = _ref$scrollAlign === void 0 ? 'center' : _ref$scrollAlign,\n    scaleCallback = _ref.scaleCallback,\n    scaleResetCallback = _ref.scaleResetCallback,\n    onIndexChange = _ref.onIndexChange,\n    onDetectActiveItem = _ref.onDetectActiveItem,\n    _ref$animatedScrollBy = _ref.animatedScrollByIndex,\n    animatedScrollByIndex = _ref$animatedScrollBy === void 0 ? false : _ref$animatedScrollBy,\n    _ref$throttleMs = _ref.throttleMs,\n    throttleMs = _ref$throttleMs === void 0 ? THROTTLE_DEFAULT_MS : _ref$throttleMs,\n    _ref$debounceMs = _ref.debounceMs,\n    debounceMs = _ref$debounceMs === void 0 ? DEBOUNCE_DEFAULT_MS : _ref$debounceMs;\n  var prevIndex = useRef(null);\n  var direction = useRef(null);\n  var offset = useRef(0);\n  var scrollRef = useRef(null);\n  var trackRef = useRef(null);\n  /**\n   * Для того, чтобы не спамить изменениями индекса.\n   * Задержка дебаунса слегка больше, чем у тротлинга.\n   * Таким образом, событие срабатывает при завершении скролла.\n   */\n\n  var debouncedOnIndexChange = useDebouncedFunction(function (i) {\n    return onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(i);\n  }, debounceMs);\n  /**\n   * Вычисление центрального элемента.\n   * Подсчет: от 0 до 1, какое количество ширины/высоты\n   * каждого элемента находится по центру скролла.\n   */\n\n  var throttledDetectActiveItem = useMemo(function () {\n    return throttle(function () {\n      if (!detectActive || scrollRef.current === null || trackRef.current === null) {\n        return;\n      }\n      /**\n       * Правая (или нижняя для Оу) граница элемента.\n       */\n\n      var itemEdge = offset.current;\n      /**\n       * Смещение (отрицательный или положительный отступ)\n       * и размер карусели (для Ox - ширина, для Oy - высота).\n       */\n\n      var scrollPos = scrollRef.current[axis === 'x' ? 'scrollLeft' : 'scrollTop'];\n      var scrollSize = scrollRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n      /**\n       * Граница скролла (видимой части).\n       * Смещение + размер.\n       */\n\n      var scrollEdge = scrollPos + scrollSize;\n      /**\n       * Элементы перед, после и в видимой части.\n       * перед [ ВИДИМЫЕ ] после\n       */\n\n      var prevItems = [];\n      var nextItems = [];\n      var count = 0;\n      var items = getCarouselItems(trackRef.current);\n      /**\n       * Проходим по всему списку, суммируя ширины элементов,\n       * пока не найдем один элемент, чей центр будет в центре карусели.\n       */\n\n      for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {\n        var _prevIndex$current;\n        var item = items.item(itemIndex);\n        if (item === null) {\n          continue;\n        }\n        /**\n         * Для Ox - ширина, для Oy - высота.\n         */\n\n        var itemSize = item[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n        /**\n         * Все элементы правее вьюпорта выпадают из процедуры.\n         * Сравниваем по предыдущему элементу.\n         * [ ... ] ...|n| <- Левый край элемента за пределами начала видимой части\n         */\n\n        if (itemEdge > scrollEdge) {\n          if (scaleCallback && scaleResetCallback) {\n            nextItems.push(item);\n          }\n          continue;\n        }\n        itemEdge += itemSize;\n        /**\n         * Все элементы левее вьюпорта выпадают из процедуры.\n         * Сравниваем по текущему элементу.\n         * Правый край элемента за пределами начала видимой части -> |p|... [ ... ]\n         */\n\n        if (scrollPos > itemEdge) {\n          if (scaleCallback && scaleResetCallback) {\n            prevItems.push(item);\n          }\n          continue;\n        }\n        var itemSlot = getItemSlot(itemIndex, itemEdge, itemSize, scrollPos, scrollSize, scrollAlign, (_prevIndex$current = prevIndex.current) !== null && _prevIndex$current !== void 0 ? _prevIndex$current : 0, offset.current);\n        if (itemSlot !== null) {\n          if (detectThreshold && Math.abs(itemSlot) <= detectThreshold) {\n            onDetectActiveItem === null || onDetectActiveItem === void 0 ? void 0 : onDetectActiveItem(itemIndex);\n            debouncedOnIndexChange === null || debouncedOnIndexChange === void 0 ? void 0 : debouncedOnIndexChange(itemIndex);\n          }\n          if (scaleCallback) {\n            scaleCallback(item, itemSlot);\n            /**\n             * Количество айтемов в видимой части.\n             */\n\n            count++;\n          }\n        }\n      }\n      if (scaleCallback && scaleResetCallback) {\n        window.requestAnimationFrame(function () {\n          if (direction.current) {\n            if (nextItems.length) {\n              nextItems.splice(0, count).forEach(function (elem) {\n                return scaleCallback(elem, count);\n              });\n              if (nextItems.length) {\n                nextItems.splice(0, count).forEach(function (elem) {\n                  return scaleResetCallback(elem);\n                });\n              }\n            }\n          } else if (prevItems.length) {\n            var prItemsRev = prevItems.reverse();\n            prItemsRev.splice(0, count).forEach(function (elem) {\n              return scaleCallback(elem, count * -1);\n            });\n            if (prItemsRev.length) {\n              prItemsRev.splice(0, count).forEach(function (elem) {\n                return scaleResetCallback(elem);\n              });\n            }\n          }\n        });\n      }\n    }, throttleMs);\n  }, [axis, debouncedOnIndexChange, detectActive, detectThreshold, onDetectActiveItem, scaleCallback, scaleResetCallback, scrollAlign, throttleMs]);\n  /**\n   * Прокрутка до нужной позиции индекса.\n   */\n\n  var toIndex = useCallback(function (i) {\n    var scrollEl = scrollRef.current;\n    var items = trackRef.current ? getCarouselItems(trackRef.current) : null;\n    if (scrollEl && items && items.length > 0 && i >= 0) {\n      scrollToPos({\n        scrollEl: scrollEl,\n        pos: getCalculatedPos({\n          scrollEl: scrollEl,\n          items: items,\n          axis: axis,\n          index: i,\n          offset: offset.current,\n          scrollAlign: scrollAlign\n        }),\n        axis: axis,\n        /**\n         * Без анимации при переходе на другой конец списка\n         */\n        animated: animatedScrollByIndex && (prevIndex.current === null || Math.abs(i - prevIndex.current) !== items.length - 1)\n      });\n      prevIndex.current = i;\n    }\n  }, [animatedScrollByIndex, axis, scrollAlign]);\n  useEffect(function () {\n    if (scrollRef.current && trackRef.current) {\n      offset.current = getCalculatedOffset(scrollRef.current, trackRef.current, axis);\n    }\n  }, [axis]);\n  /**\n   * Операции на маунте/анмаунте компонента.\n   * Создать слушатели событи и т.п.\n   */\n\n  useEffect(function () {\n    var carouselElement = scrollRef.current;\n    if (carouselElement) {\n      carouselElement.addEventListener('scroll', throttledDetectActiveItem);\n    }\n    return function () {\n      if (carouselElement) {\n        carouselElement.removeEventListener('scroll', throttledDetectActiveItem);\n      }\n    };\n  }, [throttledDetectActiveItem]);\n  /**\n   * Нужно вызвать только при первом рендере\n   */\n\n  useEffect(function () {\n    requestAnimationFrame(function () {\n      /**\n       * Прокрутка до начального индекса.\n       */\n      toIndex(index);\n      /**\n       * Если на момент запуска карусель уже находится на нужной позиции,\n       * событие скролла не произойдет, не сработает и определение центра,\n       * необходимо вызвать его вручную.\n       */\n\n      throttledDetectActiveItem();\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  /**\n   * Прокрутка до нужной позиции индекса, если индекс изменился.\n   */\n\n  useEffect(function () {\n    if (index !== prevIndex.current) {\n      toIndex(index);\n    }\n  }, [index, toIndex]);\n  return {\n    scrollRef: scrollRef,\n    trackRef: trackRef\n  };\n};\nexport function useCarouselLite(_ref2) {\n  var index = _ref2.index,\n    axis = _ref2.axis,\n    _ref2$scrollAlign = _ref2.scrollAlign,\n    scrollAlign = _ref2$scrollAlign === void 0 ? 'center' : _ref2$scrollAlign,\n    _ref2$scrollMode = _ref2.scrollMode,\n    scrollMode = _ref2$scrollMode === void 0 ? 'translate' : _ref2$scrollMode;\n  var _useState = useState(index),\n    _useState2 = _slicedToArray(_useState, 2),\n    prevIndex = _useState2[0],\n    setPrevIndex = _useState2[1];\n  var carouselRef = useRef(null);\n  var trackRef = useRef(null);\n  var needTranslateToInitialIndex = useRef(true); // Первый раз нужно проскролить к индексу, после первого рендера\n\n  useLayoutEffect(function () {\n    if (needTranslateToInitialIndex.current === false) {\n      return;\n    }\n    /**\n     * Вызываем через requestAnimationFrame, так как при использовании динамических CarouselCol\n     * ширины элементов высчитываются неверно внутри translateToIndex при синхронном вызове\n     */\n\n    var rafId = requestAnimationFrame(function () {\n      translateToIndex(index, index, axis, scrollAlign, trackRef.current, carouselRef.current, true, scrollMode);\n      needTranslateToInitialIndex.current = false;\n    });\n    return function () {\n      cancelAnimationFrame(rafId);\n    };\n  }, [axis, index, scrollAlign, scrollMode]);\n  /**\n   * Все последующие разы вызываем translateToIndex при изменении index прямо из рендера\n   */\n\n  if (index !== prevIndex) {\n    translateToIndex(index, prevIndex, axis, scrollAlign, trackRef.current, carouselRef.current, false, scrollMode);\n    setPrevIndex(index);\n  }\n  return {\n    scrollRef: carouselRef,\n    trackRef: trackRef\n  };\n}","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","throttle","useRef","useEffect","useCallback","useMemo","useLayoutEffect","useState","useDebouncedFunction","scrollToPos","getCalculatedPos","getCalculatedOffset","getItemSlot","getCarouselItems","translateToIndex","THROTTLE_DEFAULT_MS","DEBOUNCE_DEFAULT_MS","useCarousel","_ref","index","axis","_ref$detectActive","detectActive","_ref$detectThreshold","detectThreshold","_ref$scrollAlign","scrollAlign","scaleCallback","scaleResetCallback","onIndexChange","onDetectActiveItem","_ref$animatedScrollBy","animatedScrollByIndex","_ref$throttleMs","throttleMs","_ref$debounceMs","debounceMs","prevIndex","direction","offset","scrollRef","trackRef","debouncedOnIndexChange","throttledDetectActiveItem","current","itemEdge","scrollPos","scrollSize","scrollEdge","prevItems","nextItems","count","items","itemIndex","_prevIndex$current","item","itemSize","itemSlot","Math","abs","window","requestAnimationFrame","splice","forEach","elem","prItemsRev","reverse","toIndex","scrollEl","pos","animated","carouselElement","addEventListener","removeEventListener","useCarouselLite","_ref2","_ref2$scrollAlign","_ref2$scrollMode","scrollMode","_useState","_useState2","setPrevIndex","carouselRef","needTranslateToInitialIndex","rafId","cancelAnimationFrame"],"sources":["C:/Users/20618801/Desktop/src/node_modules/@salutejs/plasma-core/es/components/Carousel/hooks.js"],"sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* eslint-disable no-continue */\nimport throttle from 'lodash.throttle';\nimport { useRef, useEffect, useCallback, useMemo, useLayoutEffect, useState } from 'react';\nimport { useDebouncedFunction } from '../../hooks';\nimport { scrollToPos, getCalculatedPos, getCalculatedOffset, getItemSlot, getCarouselItems, translateToIndex } from './utils';\nvar THROTTLE_DEFAULT_MS = 100;\nvar DEBOUNCE_DEFAULT_MS = 150;\nexport var useCarousel = function useCarousel(_ref) {\n  var index = _ref.index,\n      axis = _ref.axis,\n      _ref$detectActive = _ref.detectActive,\n      detectActive = _ref$detectActive === void 0 ? false : _ref$detectActive,\n      _ref$detectThreshold = _ref.detectThreshold,\n      detectThreshold = _ref$detectThreshold === void 0 ? 0.5 : _ref$detectThreshold,\n      _ref$scrollAlign = _ref.scrollAlign,\n      scrollAlign = _ref$scrollAlign === void 0 ? 'center' : _ref$scrollAlign,\n      scaleCallback = _ref.scaleCallback,\n      scaleResetCallback = _ref.scaleResetCallback,\n      onIndexChange = _ref.onIndexChange,\n      onDetectActiveItem = _ref.onDetectActiveItem,\n      _ref$animatedScrollBy = _ref.animatedScrollByIndex,\n      animatedScrollByIndex = _ref$animatedScrollBy === void 0 ? false : _ref$animatedScrollBy,\n      _ref$throttleMs = _ref.throttleMs,\n      throttleMs = _ref$throttleMs === void 0 ? THROTTLE_DEFAULT_MS : _ref$throttleMs,\n      _ref$debounceMs = _ref.debounceMs,\n      debounceMs = _ref$debounceMs === void 0 ? DEBOUNCE_DEFAULT_MS : _ref$debounceMs;\n  var prevIndex = useRef(null);\n  var direction = useRef(null);\n  var offset = useRef(0);\n  var scrollRef = useRef(null);\n  var trackRef = useRef(null);\n  /**\n   * Для того, чтобы не спамить изменениями индекса.\n   * Задержка дебаунса слегка больше, чем у тротлинга.\n   * Таким образом, событие срабатывает при завершении скролла.\n   */\n\n  var debouncedOnIndexChange = useDebouncedFunction(function (i) {\n    return onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(i);\n  }, debounceMs);\n  /**\n   * Вычисление центрального элемента.\n   * Подсчет: от 0 до 1, какое количество ширины/высоты\n   * каждого элемента находится по центру скролла.\n   */\n\n  var throttledDetectActiveItem = useMemo(function () {\n    return throttle(function () {\n      if (!detectActive || scrollRef.current === null || trackRef.current === null) {\n        return;\n      }\n      /**\n       * Правая (или нижняя для Оу) граница элемента.\n       */\n\n\n      var itemEdge = offset.current;\n      /**\n       * Смещение (отрицательный или положительный отступ)\n       * и размер карусели (для Ox - ширина, для Oy - высота).\n       */\n\n      var scrollPos = scrollRef.current[axis === 'x' ? 'scrollLeft' : 'scrollTop'];\n      var scrollSize = scrollRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n      /**\n       * Граница скролла (видимой части).\n       * Смещение + размер.\n       */\n\n      var scrollEdge = scrollPos + scrollSize;\n      /**\n       * Элементы перед, после и в видимой части.\n       * перед [ ВИДИМЫЕ ] после\n       */\n\n      var prevItems = [];\n      var nextItems = [];\n      var count = 0;\n      var items = getCarouselItems(trackRef.current);\n      /**\n       * Проходим по всему списку, суммируя ширины элементов,\n       * пока не найдем один элемент, чей центр будет в центре карусели.\n       */\n\n      for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {\n        var _prevIndex$current;\n\n        var item = items.item(itemIndex);\n\n        if (item === null) {\n          continue;\n        }\n        /**\n         * Для Ox - ширина, для Oy - высота.\n         */\n\n\n        var itemSize = item[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n        /**\n         * Все элементы правее вьюпорта выпадают из процедуры.\n         * Сравниваем по предыдущему элементу.\n         * [ ... ] ...|n| <- Левый край элемента за пределами начала видимой части\n         */\n\n        if (itemEdge > scrollEdge) {\n          if (scaleCallback && scaleResetCallback) {\n            nextItems.push(item);\n          }\n\n          continue;\n        }\n\n        itemEdge += itemSize;\n        /**\n         * Все элементы левее вьюпорта выпадают из процедуры.\n         * Сравниваем по текущему элементу.\n         * Правый край элемента за пределами начала видимой части -> |p|... [ ... ]\n         */\n\n        if (scrollPos > itemEdge) {\n          if (scaleCallback && scaleResetCallback) {\n            prevItems.push(item);\n          }\n\n          continue;\n        }\n\n        var itemSlot = getItemSlot(itemIndex, itemEdge, itemSize, scrollPos, scrollSize, scrollAlign, (_prevIndex$current = prevIndex.current) !== null && _prevIndex$current !== void 0 ? _prevIndex$current : 0, offset.current);\n\n        if (itemSlot !== null) {\n          if (detectThreshold && Math.abs(itemSlot) <= detectThreshold) {\n            onDetectActiveItem === null || onDetectActiveItem === void 0 ? void 0 : onDetectActiveItem(itemIndex);\n            debouncedOnIndexChange === null || debouncedOnIndexChange === void 0 ? void 0 : debouncedOnIndexChange(itemIndex);\n          }\n\n          if (scaleCallback) {\n            scaleCallback(item, itemSlot);\n            /**\n             * Количество айтемов в видимой части.\n             */\n\n            count++;\n          }\n        }\n      }\n\n      if (scaleCallback && scaleResetCallback) {\n        window.requestAnimationFrame(function () {\n          if (direction.current) {\n            if (nextItems.length) {\n              nextItems.splice(0, count).forEach(function (elem) {\n                return scaleCallback(elem, count);\n              });\n\n              if (nextItems.length) {\n                nextItems.splice(0, count).forEach(function (elem) {\n                  return scaleResetCallback(elem);\n                });\n              }\n            }\n          } else if (prevItems.length) {\n            var prItemsRev = prevItems.reverse();\n            prItemsRev.splice(0, count).forEach(function (elem) {\n              return scaleCallback(elem, count * -1);\n            });\n\n            if (prItemsRev.length) {\n              prItemsRev.splice(0, count).forEach(function (elem) {\n                return scaleResetCallback(elem);\n              });\n            }\n          }\n        });\n      }\n    }, throttleMs);\n  }, [axis, debouncedOnIndexChange, detectActive, detectThreshold, onDetectActiveItem, scaleCallback, scaleResetCallback, scrollAlign, throttleMs]);\n  /**\n   * Прокрутка до нужной позиции индекса.\n   */\n\n  var toIndex = useCallback(function (i) {\n    var scrollEl = scrollRef.current;\n    var items = trackRef.current ? getCarouselItems(trackRef.current) : null;\n\n    if (scrollEl && items && items.length > 0 && i >= 0) {\n      scrollToPos({\n        scrollEl: scrollEl,\n        pos: getCalculatedPos({\n          scrollEl: scrollEl,\n          items: items,\n          axis: axis,\n          index: i,\n          offset: offset.current,\n          scrollAlign: scrollAlign\n        }),\n        axis: axis,\n\n        /**\n         * Без анимации при переходе на другой конец списка\n         */\n        animated: animatedScrollByIndex && (prevIndex.current === null || Math.abs(i - prevIndex.current) !== items.length - 1)\n      });\n      prevIndex.current = i;\n    }\n  }, [animatedScrollByIndex, axis, scrollAlign]);\n  useEffect(function () {\n    if (scrollRef.current && trackRef.current) {\n      offset.current = getCalculatedOffset(scrollRef.current, trackRef.current, axis);\n    }\n  }, [axis]);\n  /**\n   * Операции на маунте/анмаунте компонента.\n   * Создать слушатели событи и т.п.\n   */\n\n  useEffect(function () {\n    var carouselElement = scrollRef.current;\n\n    if (carouselElement) {\n      carouselElement.addEventListener('scroll', throttledDetectActiveItem);\n    }\n\n    return function () {\n      if (carouselElement) {\n        carouselElement.removeEventListener('scroll', throttledDetectActiveItem);\n      }\n    };\n  }, [throttledDetectActiveItem]);\n  /**\n   * Нужно вызвать только при первом рендере\n   */\n\n  useEffect(function () {\n    requestAnimationFrame(function () {\n      /**\n       * Прокрутка до начального индекса.\n       */\n      toIndex(index);\n      /**\n       * Если на момент запуска карусель уже находится на нужной позиции,\n       * событие скролла не произойдет, не сработает и определение центра,\n       * необходимо вызвать его вручную.\n       */\n\n      throttledDetectActiveItem();\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  /**\n   * Прокрутка до нужной позиции индекса, если индекс изменился.\n   */\n\n  useEffect(function () {\n    if (index !== prevIndex.current) {\n      toIndex(index);\n    }\n  }, [index, toIndex]);\n  return {\n    scrollRef: scrollRef,\n    trackRef: trackRef\n  };\n};\nexport function useCarouselLite(_ref2) {\n  var index = _ref2.index,\n      axis = _ref2.axis,\n      _ref2$scrollAlign = _ref2.scrollAlign,\n      scrollAlign = _ref2$scrollAlign === void 0 ? 'center' : _ref2$scrollAlign,\n      _ref2$scrollMode = _ref2.scrollMode,\n      scrollMode = _ref2$scrollMode === void 0 ? 'translate' : _ref2$scrollMode;\n\n  var _useState = useState(index),\n      _useState2 = _slicedToArray(_useState, 2),\n      prevIndex = _useState2[0],\n      setPrevIndex = _useState2[1];\n\n  var carouselRef = useRef(null);\n  var trackRef = useRef(null);\n  var needTranslateToInitialIndex = useRef(true); // Первый раз нужно проскролить к индексу, после первого рендера\n\n  useLayoutEffect(function () {\n    if (needTranslateToInitialIndex.current === false) {\n      return;\n    }\n    /**\n     * Вызываем через requestAnimationFrame, так как при использовании динамических CarouselCol\n     * ширины элементов высчитываются неверно внутри translateToIndex при синхронном вызове\n     */\n\n\n    var rafId = requestAnimationFrame(function () {\n      translateToIndex(index, index, axis, scrollAlign, trackRef.current, carouselRef.current, true, scrollMode);\n      needTranslateToInitialIndex.current = false;\n    });\n    return function () {\n      cancelAnimationFrame(rafId);\n    };\n  }, [axis, index, scrollAlign, scrollMode]);\n  /**\n   * Все последующие разы вызываем translateToIndex при изменении index прямо из рендера\n   */\n\n  if (index !== prevIndex) {\n    translateToIndex(index, prevIndex, axis, scrollAlign, trackRef.current, carouselRef.current, false, scrollMode);\n    setPrevIndex(index);\n  }\n\n  return {\n    scrollRef: carouselRef,\n    trackRef: trackRef\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}