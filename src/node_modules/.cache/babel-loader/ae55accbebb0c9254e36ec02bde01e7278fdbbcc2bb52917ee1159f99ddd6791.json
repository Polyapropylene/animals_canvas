{"ast":null,"code":"import { animatedScrollToX, animatedScrollToY } from '../../utils';\nvar positionModByScrollAlign = function positionModByScrollAlign(_ref) {\n  var scrollAlign = _ref.scrollAlign,\n    position = _ref.position,\n    carouselSize = _ref.carouselSize,\n    itemSize = _ref.itemSize,\n    offset = _ref.offset,\n    scrollStart = _ref.scrollStart,\n    axis = _ref.axis;\n  if (scrollAlign === 'start') {\n    var inaccuracy = 1;\n    var paddingOffset = axis === 'y' ? offset - itemSize / 2 + inaccuracy : 0;\n    return position + paddingOffset;\n  }\n  if (scrollAlign === 'center') {\n    return position - carouselSize / 2 + itemSize / 2;\n  }\n  if (scrollAlign === 'end') {\n    return position - carouselSize + itemSize + offset;\n  }\n  if (scrollAlign === 'activeDirection') {\n    if (position >= scrollStart + carouselSize - itemSize) {\n      return position - carouselSize + itemSize + offset;\n    }\n    if (position > scrollStart) {\n      return scrollStart;\n    }\n  }\n  return position;\n};\n/**\n * Подсчет скролла до переданного индекса.\n */\n\nexport var getCalculatedPos = function getCalculatedPos(_ref2) {\n  var scrollEl = _ref2.scrollEl,\n    items = _ref2.items,\n    axis = _ref2.axis,\n    index = _ref2.index,\n    offset = _ref2.offset,\n    scrollAlign = _ref2.scrollAlign;\n  var position = scrollAlign === 'center' ? offset : 0;\n  var carouselSize;\n  var itemSize;\n  var scrollStart;\n  if (items.item(index) === null) {\n    return position;\n  }\n  for (var i = 0; i < index; i++) {\n    if (axis === 'x') {\n      var _items$item$offsetWid, _items$item;\n      position += (_items$item$offsetWid = (_items$item = items.item(i)) === null || _items$item === void 0 ? void 0 : _items$item.offsetWidth) !== null && _items$item$offsetWid !== void 0 ? _items$item$offsetWid : 0;\n    } else {\n      var _items$item$offsetHei, _items$item2;\n      position += (_items$item$offsetHei = (_items$item2 = items.item(i)) === null || _items$item2 === void 0 ? void 0 : _items$item2.offsetHeight) !== null && _items$item$offsetHei !== void 0 ? _items$item$offsetHei : 0;\n    }\n  }\n  if (axis === 'x') {\n    var _items$item$offsetWid2, _items$item3;\n    carouselSize = scrollEl.offsetWidth;\n    itemSize = (_items$item$offsetWid2 = (_items$item3 = items.item(index)) === null || _items$item3 === void 0 ? void 0 : _items$item3.offsetWidth) !== null && _items$item$offsetWid2 !== void 0 ? _items$item$offsetWid2 : 0;\n    scrollStart = scrollEl.scrollLeft;\n  } else {\n    var _items$item$offsetHei2, _items$item4;\n    carouselSize = scrollEl.offsetHeight;\n    itemSize = (_items$item$offsetHei2 = (_items$item4 = items.item(index)) === null || _items$item4 === void 0 ? void 0 : _items$item4.offsetHeight) !== null && _items$item$offsetHei2 !== void 0 ? _items$item$offsetHei2 : 0;\n    scrollStart = scrollEl.scrollTop;\n  }\n  return positionModByScrollAlign({\n    scrollAlign: scrollAlign,\n    position: position,\n    carouselSize: carouselSize,\n    itemSize: itemSize,\n    offset: offset,\n    scrollStart: scrollStart,\n    axis: axis\n  });\n};\n/**\n * Подсчет смещения из-за паддингов.\n */\n\nexport var getCalculatedOffset = function getCalculatedOffset(scrollEl, trackEl, axis) {\n  var paddingProp = axis === 'x' ? 'paddingLeft' : 'paddingTop';\n  return parseInt(getComputedStyle(scrollEl)[paddingProp], 10) + parseInt(getComputedStyle(trackEl)[paddingProp], 10);\n};\n/**\n * Прокрутка к указанной позиции с анимацией или без.\n */\n\nexport var scrollToPos = function scrollToPos(_ref3) {\n  var scrollEl = _ref3.scrollEl,\n    pos = _ref3.pos,\n    axis = _ref3.axis,\n    animated = _ref3.animated,\n    duration = _ref3.duration,\n    timingFunction = _ref3.timingFunction;\n  if (axis === 'x' && Math.abs(pos - scrollEl.scrollLeft) > 1) {\n    if (animated) {\n      animatedScrollToX(scrollEl, pos, duration, timingFunction);\n    } else {\n      scrollEl.scrollTo({\n        left: pos\n      });\n    }\n  }\n  if (axis === 'y' && Math.abs(pos - scrollEl.scrollTop) > 1) {\n    if (animated) {\n      animatedScrollToY(scrollEl, pos, duration, timingFunction);\n    } else {\n      scrollEl.scrollTo({\n        top: pos\n      });\n    }\n  }\n};\nvar round = function round(n) {\n  return Math.round(n * 100) / 100;\n};\n/**\n * Получить позицию (слот) айтема в каруселе.\n * Каждый айтем имеет свой слот относительно вьюпорта карусели.\n */\n\nexport var getItemSlot = function getItemSlot(itemIndex, itemEnd, itemSize, scrollStart, scrollSize, scrollAlign) {\n  var prevIndex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var offset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n\n  /**\n   * Граница и центр скролла (видимой части).\n   * Смещение + размер.\n   */\n  var scrollEnd = scrollStart + scrollSize;\n  var scrollCenter = scrollStart + scrollSize / 2;\n  var itemCenter = itemEnd - itemSize / 2;\n  if (scrollAlign === 'center') {\n    return round((itemCenter - scrollCenter) / itemSize);\n  }\n  if (scrollAlign === 'start') {\n    return round((itemEnd - itemSize - scrollStart) / itemSize);\n  }\n  if (scrollAlign === 'end') {\n    return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n  }\n  if (scrollAlign === 'activeDirection') {\n    var prevStart = offset + itemSize * prevIndex;\n    var prevEnd = prevStart + itemSize;\n    var prevVisible = prevEnd > scrollStart && prevStart < scrollEnd;\n    if (!prevVisible) {\n      if (prevIndex < itemIndex) {\n        return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n      }\n      return round((itemEnd - itemSize - scrollStart) / itemSize);\n    }\n  }\n  return null;\n};\nexport function getCarouselItems(track) {\n  return track.children;\n}\nvar axisToTranslateMap = {\n  x: function x(position) {\n    return \"translateX(\".concat(-position, \"px)\");\n  },\n  y: function y(position) {\n    return \"translateY(\".concat(-position, \"px)\");\n  }\n};\nvar axisToOffsetKeyMap = {\n  x: 'offsetLeft',\n  y: 'offsetTop'\n};\nvar axisToSizeKeyMap = {\n  x: 'offsetWidth',\n  y: 'offsetHeight'\n};\nvar axisToScrollKeyMap = {\n  x: 'scrollLeft',\n  y: 'scrollTop'\n};\nfunction getCenterPosition(itemSize, itemStart, carouselSize, trackOffset) {\n  var relativeMiddle = itemStart + trackOffset + itemSize / 2;\n  return relativeMiddle - carouselSize / 2;\n}\nfunction getEndPosition(itemSize, itemStart, carouselSize, trackOffset) {\n  return 2 * trackOffset + itemStart + itemSize - carouselSize;\n}\nfunction getTranslatePosition(itemSize, itemStart, carouselSize, trackOffset, scrollAlign) {\n  switch (scrollAlign) {\n    case 'start':\n      {\n        return itemStart;\n      }\n    case 'end':\n      {\n        return getEndPosition(itemSize, itemStart, carouselSize, trackOffset);\n      }\n    case 'center':\n    case 'activeDirection': // TODO: activeDirection сделать позже, мало кто использует. Fallback на 'center'\n\n    default:\n      return getCenterPosition(itemSize, itemStart, carouselSize, trackOffset);\n  }\n}\nfunction boundPosition(position, trackSize, carouselSize, trackOffset) {\n  if (position < 0) {\n    return 0;\n  } // если все элементы помещаются в ширину карусели, то считаем trackEnd по-другому\n\n  if (trackSize < carouselSize) {\n    var _trackEnd = Math.abs(carouselSize - trackSize - trackOffset);\n    return position < _trackEnd ? position : _trackEnd;\n  }\n  var trackEnd = trackSize - carouselSize + trackOffset;\n  if (position > trackEnd) {\n    return trackEnd;\n  }\n  return position;\n}\n/**\n * Функция решает являются ли переданные индексы крайними с начала и конца.\n * Например в такой карусели `([1][2][3][4])` — при изменении индекса с 4 на 1 или наоборот функция вернёт `true`,\n * так как это переход между крайними элементами.\n *\n * Есть исключение, для карусели длинной в 2 элемента `([1][2])`.\n * В этом случае переход с индекса 1 на 2 и наоборот не должен считаться переходом с одного края на другой.\n *\n * @param prevIndex\n * @param index\n * @param numberOfItems количество элементов в карусели\n */\n\nfunction isMaximumDistance(prevIndex, index, numberOfItems) {\n  // проверка, что карусель состоит из 2-х элементов\n  if (numberOfItems === 2) {\n    return false;\n  }\n  return Math.abs(index - prevIndex) === numberOfItems - 1;\n}\nfunction setTimingFunction(element, timingFunction) {\n  if (element) {\n    element.style.transitionTimingFunction = timingFunction;\n  }\n}\nfunction translateToPosition(element, axis, position) {\n  var translate = axisToTranslateMap[axis];\n  element.style.transform = translate(position);\n}\nvar scrollOptions = {\n  behavior: 'auto',\n  left: 0,\n  top: 0\n};\n/**\n * Делает расчет следующей позиции карусели исходя из параметров\n * index, align и размеров элементов track и carousel.\n * После применяет transform к элементу track или вызывает scrollTo на элементе carousel.\n * При scrollMode равном translate Анимирование происходит из-за CSS свойства `transition-property: transform`,\n * применённому к элементу track\n *\n * @param index индекс элемента к которому нужно сделать transform\n * @param prevIndex индекс предыдущего активного элемента для расчёта дистанции между индексами\n * @param axis ось вдоль которой будет происходить transform\n * @param align определяет позицию активного элемента относительно элемента carousel\n * @param track элемент к которому применяется transform\n * @param carousel элемент содержащий track\n * @param disableAnimation флаг для отключения анимирования прокрутки\n * @param scrollMode прокрутка через scrollTo или через translate\n */\n\nexport function translateToIndex(index, prevIndex, axis, align, track, carousel, disableAnimation, scrollMode) {\n  if (track === null || carousel === null) {\n    return;\n  }\n  var scrollKey = axisToScrollKeyMap[axis];\n  if (disableAnimation === false && scrollMode === 'translate' && carousel[scrollKey] !== 0) {\n    carousel.scrollTo(scrollOptions);\n  }\n  var itemToTranslateTo = track.children.item(index);\n  if (itemToTranslateTo === null) {\n    return;\n  }\n  var numberOfItems = track.children.length;\n  var offsetKey = axisToOffsetKeyMap[axis];\n  var sizeKey = axisToSizeKeyMap[axis];\n  var carouselSize = carousel[sizeKey];\n  var trackSize = track[sizeKey];\n  var trackOffset = track[offsetKey];\n  var itemSize = itemToTranslateTo[sizeKey];\n  var itemStart = itemToTranslateTo[offsetKey];\n  var translatePosition = getTranslatePosition(itemSize, itemStart, carouselSize, trackOffset, align);\n  var position = boundPosition(translatePosition, trackSize, carouselSize, trackOffset);\n  if (scrollMode === 'scroll') {\n    carousel.scrollTo({\n      behavior: disableAnimation ? 'auto' : 'smooth',\n      left: axis === 'x' ? position : 0,\n      top: axis === 'y' ? position : 0\n    });\n    return;\n  }\n  if (disableAnimation === true || isMaximumDistance(prevIndex, index, numberOfItems) === true) {\n    // Выключаем стандартный easing, переключая его на step-start\n    setTimingFunction(track, 'step-start');\n    translateToPosition(track, axis, position);\n    /**\n     * Включаем стандартный easing.\n     * нужно делать через setTimeout, чтобы transform успел произойти до изменения transitionTimingFunction\n     */\n\n    setTimeout(setTimingFunction, 0, track, '');\n    return;\n  }\n  translateToPosition(track, axis, position);\n}","map":{"version":3,"names":["animatedScrollToX","animatedScrollToY","positionModByScrollAlign","_ref","scrollAlign","position","carouselSize","itemSize","offset","scrollStart","axis","inaccuracy","paddingOffset","getCalculatedPos","_ref2","scrollEl","items","index","item","i","_items$item$offsetWid","_items$item","offsetWidth","_items$item$offsetHei","_items$item2","offsetHeight","_items$item$offsetWid2","_items$item3","scrollLeft","_items$item$offsetHei2","_items$item4","scrollTop","getCalculatedOffset","trackEl","paddingProp","parseInt","getComputedStyle","scrollToPos","_ref3","pos","animated","duration","timingFunction","Math","abs","scrollTo","left","top","round","n","getItemSlot","itemIndex","itemEnd","scrollSize","prevIndex","arguments","length","undefined","scrollEnd","scrollCenter","itemCenter","prevStart","prevEnd","prevVisible","getCarouselItems","track","children","axisToTranslateMap","x","concat","y","axisToOffsetKeyMap","axisToSizeKeyMap","axisToScrollKeyMap","getCenterPosition","itemStart","trackOffset","relativeMiddle","getEndPosition","getTranslatePosition","boundPosition","trackSize","_trackEnd","trackEnd","isMaximumDistance","numberOfItems","setTimingFunction","element","style","transitionTimingFunction","translateToPosition","translate","transform","scrollOptions","behavior","translateToIndex","align","carousel","disableAnimation","scrollMode","scrollKey","itemToTranslateTo","offsetKey","sizeKey","translatePosition","setTimeout"],"sources":["/Users/polechkagadukina/Desktop/src/node_modules/@salutejs/plasma-core/es/components/Carousel/utils.js"],"sourcesContent":["import { animatedScrollToX, animatedScrollToY } from '../../utils';\n\nvar positionModByScrollAlign = function positionModByScrollAlign(_ref) {\n  var scrollAlign = _ref.scrollAlign,\n      position = _ref.position,\n      carouselSize = _ref.carouselSize,\n      itemSize = _ref.itemSize,\n      offset = _ref.offset,\n      scrollStart = _ref.scrollStart,\n      axis = _ref.axis;\n\n  if (scrollAlign === 'start') {\n    var inaccuracy = 1;\n    var paddingOffset = axis === 'y' ? offset - itemSize / 2 + inaccuracy : 0;\n    return position + paddingOffset;\n  }\n\n  if (scrollAlign === 'center') {\n    return position - carouselSize / 2 + itemSize / 2;\n  }\n\n  if (scrollAlign === 'end') {\n    return position - carouselSize + itemSize + offset;\n  }\n\n  if (scrollAlign === 'activeDirection') {\n    if (position >= scrollStart + carouselSize - itemSize) {\n      return position - carouselSize + itemSize + offset;\n    }\n\n    if (position > scrollStart) {\n      return scrollStart;\n    }\n  }\n\n  return position;\n};\n/**\n * Подсчет скролла до переданного индекса.\n */\n\n\nexport var getCalculatedPos = function getCalculatedPos(_ref2) {\n  var scrollEl = _ref2.scrollEl,\n      items = _ref2.items,\n      axis = _ref2.axis,\n      index = _ref2.index,\n      offset = _ref2.offset,\n      scrollAlign = _ref2.scrollAlign;\n  var position = scrollAlign === 'center' ? offset : 0;\n  var carouselSize;\n  var itemSize;\n  var scrollStart;\n\n  if (items.item(index) === null) {\n    return position;\n  }\n\n  for (var i = 0; i < index; i++) {\n    if (axis === 'x') {\n      var _items$item$offsetWid, _items$item;\n\n      position += (_items$item$offsetWid = (_items$item = items.item(i)) === null || _items$item === void 0 ? void 0 : _items$item.offsetWidth) !== null && _items$item$offsetWid !== void 0 ? _items$item$offsetWid : 0;\n    } else {\n      var _items$item$offsetHei, _items$item2;\n\n      position += (_items$item$offsetHei = (_items$item2 = items.item(i)) === null || _items$item2 === void 0 ? void 0 : _items$item2.offsetHeight) !== null && _items$item$offsetHei !== void 0 ? _items$item$offsetHei : 0;\n    }\n  }\n\n  if (axis === 'x') {\n    var _items$item$offsetWid2, _items$item3;\n\n    carouselSize = scrollEl.offsetWidth;\n    itemSize = (_items$item$offsetWid2 = (_items$item3 = items.item(index)) === null || _items$item3 === void 0 ? void 0 : _items$item3.offsetWidth) !== null && _items$item$offsetWid2 !== void 0 ? _items$item$offsetWid2 : 0;\n    scrollStart = scrollEl.scrollLeft;\n  } else {\n    var _items$item$offsetHei2, _items$item4;\n\n    carouselSize = scrollEl.offsetHeight;\n    itemSize = (_items$item$offsetHei2 = (_items$item4 = items.item(index)) === null || _items$item4 === void 0 ? void 0 : _items$item4.offsetHeight) !== null && _items$item$offsetHei2 !== void 0 ? _items$item$offsetHei2 : 0;\n    scrollStart = scrollEl.scrollTop;\n  }\n\n  return positionModByScrollAlign({\n    scrollAlign: scrollAlign,\n    position: position,\n    carouselSize: carouselSize,\n    itemSize: itemSize,\n    offset: offset,\n    scrollStart: scrollStart,\n    axis: axis\n  });\n};\n/**\n * Подсчет смещения из-за паддингов.\n */\n\nexport var getCalculatedOffset = function getCalculatedOffset(scrollEl, trackEl, axis) {\n  var paddingProp = axis === 'x' ? 'paddingLeft' : 'paddingTop';\n  return parseInt(getComputedStyle(scrollEl)[paddingProp], 10) + parseInt(getComputedStyle(trackEl)[paddingProp], 10);\n};\n/**\n * Прокрутка к указанной позиции с анимацией или без.\n */\n\nexport var scrollToPos = function scrollToPos(_ref3) {\n  var scrollEl = _ref3.scrollEl,\n      pos = _ref3.pos,\n      axis = _ref3.axis,\n      animated = _ref3.animated,\n      duration = _ref3.duration,\n      timingFunction = _ref3.timingFunction;\n\n  if (axis === 'x' && Math.abs(pos - scrollEl.scrollLeft) > 1) {\n    if (animated) {\n      animatedScrollToX(scrollEl, pos, duration, timingFunction);\n    } else {\n      scrollEl.scrollTo({\n        left: pos\n      });\n    }\n  }\n\n  if (axis === 'y' && Math.abs(pos - scrollEl.scrollTop) > 1) {\n    if (animated) {\n      animatedScrollToY(scrollEl, pos, duration, timingFunction);\n    } else {\n      scrollEl.scrollTo({\n        top: pos\n      });\n    }\n  }\n};\n\nvar round = function round(n) {\n  return Math.round(n * 100) / 100;\n};\n/**\n * Получить позицию (слот) айтема в каруселе.\n * Каждый айтем имеет свой слот относительно вьюпорта карусели.\n */\n\n\nexport var getItemSlot = function getItemSlot(itemIndex, itemEnd, itemSize, scrollStart, scrollSize, scrollAlign) {\n  var prevIndex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var offset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n\n  /**\n   * Граница и центр скролла (видимой части).\n   * Смещение + размер.\n   */\n  var scrollEnd = scrollStart + scrollSize;\n  var scrollCenter = scrollStart + scrollSize / 2;\n  var itemCenter = itemEnd - itemSize / 2;\n\n  if (scrollAlign === 'center') {\n    return round((itemCenter - scrollCenter) / itemSize);\n  }\n\n  if (scrollAlign === 'start') {\n    return round((itemEnd - itemSize - scrollStart) / itemSize);\n  }\n\n  if (scrollAlign === 'end') {\n    return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n  }\n\n  if (scrollAlign === 'activeDirection') {\n    var prevStart = offset + itemSize * prevIndex;\n    var prevEnd = prevStart + itemSize;\n    var prevVisible = prevEnd > scrollStart && prevStart < scrollEnd;\n\n    if (!prevVisible) {\n      if (prevIndex < itemIndex) {\n        return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n      }\n\n      return round((itemEnd - itemSize - scrollStart) / itemSize);\n    }\n  }\n\n  return null;\n};\nexport function getCarouselItems(track) {\n  return track.children;\n}\nvar axisToTranslateMap = {\n  x: function x(position) {\n    return \"translateX(\".concat(-position, \"px)\");\n  },\n  y: function y(position) {\n    return \"translateY(\".concat(-position, \"px)\");\n  }\n};\nvar axisToOffsetKeyMap = {\n  x: 'offsetLeft',\n  y: 'offsetTop'\n};\nvar axisToSizeKeyMap = {\n  x: 'offsetWidth',\n  y: 'offsetHeight'\n};\nvar axisToScrollKeyMap = {\n  x: 'scrollLeft',\n  y: 'scrollTop'\n};\n\nfunction getCenterPosition(itemSize, itemStart, carouselSize, trackOffset) {\n  var relativeMiddle = itemStart + trackOffset + itemSize / 2;\n  return relativeMiddle - carouselSize / 2;\n}\n\nfunction getEndPosition(itemSize, itemStart, carouselSize, trackOffset) {\n  return 2 * trackOffset + itemStart + itemSize - carouselSize;\n}\n\nfunction getTranslatePosition(itemSize, itemStart, carouselSize, trackOffset, scrollAlign) {\n  switch (scrollAlign) {\n    case 'start':\n      {\n        return itemStart;\n      }\n\n    case 'end':\n      {\n        return getEndPosition(itemSize, itemStart, carouselSize, trackOffset);\n      }\n\n    case 'center':\n    case 'activeDirection': // TODO: activeDirection сделать позже, мало кто использует. Fallback на 'center'\n\n    default:\n      return getCenterPosition(itemSize, itemStart, carouselSize, trackOffset);\n  }\n}\n\nfunction boundPosition(position, trackSize, carouselSize, trackOffset) {\n  if (position < 0) {\n    return 0;\n  } // если все элементы помещаются в ширину карусели, то считаем trackEnd по-другому\n\n\n  if (trackSize < carouselSize) {\n    var _trackEnd = Math.abs(carouselSize - trackSize - trackOffset);\n\n    return position < _trackEnd ? position : _trackEnd;\n  }\n\n  var trackEnd = trackSize - carouselSize + trackOffset;\n\n  if (position > trackEnd) {\n    return trackEnd;\n  }\n\n  return position;\n}\n/**\n * Функция решает являются ли переданные индексы крайними с начала и конца.\n * Например в такой карусели `([1][2][3][4])` — при изменении индекса с 4 на 1 или наоборот функция вернёт `true`,\n * так как это переход между крайними элементами.\n *\n * Есть исключение, для карусели длинной в 2 элемента `([1][2])`.\n * В этом случае переход с индекса 1 на 2 и наоборот не должен считаться переходом с одного края на другой.\n *\n * @param prevIndex\n * @param index\n * @param numberOfItems количество элементов в карусели\n */\n\n\nfunction isMaximumDistance(prevIndex, index, numberOfItems) {\n  // проверка, что карусель состоит из 2-х элементов\n  if (numberOfItems === 2) {\n    return false;\n  }\n\n  return Math.abs(index - prevIndex) === numberOfItems - 1;\n}\n\nfunction setTimingFunction(element, timingFunction) {\n  if (element) {\n    element.style.transitionTimingFunction = timingFunction;\n  }\n}\n\nfunction translateToPosition(element, axis, position) {\n  var translate = axisToTranslateMap[axis];\n  element.style.transform = translate(position);\n}\n\nvar scrollOptions = {\n  behavior: 'auto',\n  left: 0,\n  top: 0\n};\n/**\n * Делает расчет следующей позиции карусели исходя из параметров\n * index, align и размеров элементов track и carousel.\n * После применяет transform к элементу track или вызывает scrollTo на элементе carousel.\n * При scrollMode равном translate Анимирование происходит из-за CSS свойства `transition-property: transform`,\n * применённому к элементу track\n *\n * @param index индекс элемента к которому нужно сделать transform\n * @param prevIndex индекс предыдущего активного элемента для расчёта дистанции между индексами\n * @param axis ось вдоль которой будет происходить transform\n * @param align определяет позицию активного элемента относительно элемента carousel\n * @param track элемент к которому применяется transform\n * @param carousel элемент содержащий track\n * @param disableAnimation флаг для отключения анимирования прокрутки\n * @param scrollMode прокрутка через scrollTo или через translate\n */\n\nexport function translateToIndex(index, prevIndex, axis, align, track, carousel, disableAnimation, scrollMode) {\n  if (track === null || carousel === null) {\n    return;\n  }\n\n  var scrollKey = axisToScrollKeyMap[axis];\n\n  if (disableAnimation === false && scrollMode === 'translate' && carousel[scrollKey] !== 0) {\n    carousel.scrollTo(scrollOptions);\n  }\n\n  var itemToTranslateTo = track.children.item(index);\n\n  if (itemToTranslateTo === null) {\n    return;\n  }\n\n  var numberOfItems = track.children.length;\n  var offsetKey = axisToOffsetKeyMap[axis];\n  var sizeKey = axisToSizeKeyMap[axis];\n  var carouselSize = carousel[sizeKey];\n  var trackSize = track[sizeKey];\n  var trackOffset = track[offsetKey];\n  var itemSize = itemToTranslateTo[sizeKey];\n  var itemStart = itemToTranslateTo[offsetKey];\n  var translatePosition = getTranslatePosition(itemSize, itemStart, carouselSize, trackOffset, align);\n  var position = boundPosition(translatePosition, trackSize, carouselSize, trackOffset);\n\n  if (scrollMode === 'scroll') {\n    carousel.scrollTo({\n      behavior: disableAnimation ? 'auto' : 'smooth',\n      left: axis === 'x' ? position : 0,\n      top: axis === 'y' ? position : 0\n    });\n    return;\n  }\n\n  if (disableAnimation === true || isMaximumDistance(prevIndex, index, numberOfItems) === true) {\n    // Выключаем стандартный easing, переключая его на step-start\n    setTimingFunction(track, 'step-start');\n    translateToPosition(track, axis, position);\n    /**\n     * Включаем стандартный easing.\n     * нужно делать через setTimeout, чтобы transform успел произойти до изменения transitionTimingFunction\n     */\n\n    setTimeout(setTimingFunction, 0, track, '');\n    return;\n  }\n\n  translateToPosition(track, axis, position);\n}"],"mappings":"AAAA,SAASA,iBAAiB,EAAEC,iBAAiB,QAAQ,aAAa;AAElE,IAAIC,wBAAwB,GAAG,SAASA,wBAAwB,CAACC,IAAI,EAAE;EACrE,IAAIC,WAAW,GAAGD,IAAI,CAACC,WAAW;IAC9BC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;IACxBC,YAAY,GAAGH,IAAI,CAACG,YAAY;IAChCC,QAAQ,GAAGJ,IAAI,CAACI,QAAQ;IACxBC,MAAM,GAAGL,IAAI,CAACK,MAAM;IACpBC,WAAW,GAAGN,IAAI,CAACM,WAAW;IAC9BC,IAAI,GAAGP,IAAI,CAACO,IAAI;EAEpB,IAAIN,WAAW,KAAK,OAAO,EAAE;IAC3B,IAAIO,UAAU,GAAG,CAAC;IAClB,IAAIC,aAAa,GAAGF,IAAI,KAAK,GAAG,GAAGF,MAAM,GAAGD,QAAQ,GAAG,CAAC,GAAGI,UAAU,GAAG,CAAC;IACzE,OAAON,QAAQ,GAAGO,aAAa;EACjC;EAEA,IAAIR,WAAW,KAAK,QAAQ,EAAE;IAC5B,OAAOC,QAAQ,GAAGC,YAAY,GAAG,CAAC,GAAGC,QAAQ,GAAG,CAAC;EACnD;EAEA,IAAIH,WAAW,KAAK,KAAK,EAAE;IACzB,OAAOC,QAAQ,GAAGC,YAAY,GAAGC,QAAQ,GAAGC,MAAM;EACpD;EAEA,IAAIJ,WAAW,KAAK,iBAAiB,EAAE;IACrC,IAAIC,QAAQ,IAAII,WAAW,GAAGH,YAAY,GAAGC,QAAQ,EAAE;MACrD,OAAOF,QAAQ,GAAGC,YAAY,GAAGC,QAAQ,GAAGC,MAAM;IACpD;IAEA,IAAIH,QAAQ,GAAGI,WAAW,EAAE;MAC1B,OAAOA,WAAW;IACpB;EACF;EAEA,OAAOJ,QAAQ;AACjB,CAAC;AACD;AACA;AACA;;AAGA,OAAO,IAAIQ,gBAAgB,GAAG,SAASA,gBAAgB,CAACC,KAAK,EAAE;EAC7D,IAAIC,QAAQ,GAAGD,KAAK,CAACC,QAAQ;IACzBC,KAAK,GAAGF,KAAK,CAACE,KAAK;IACnBN,IAAI,GAAGI,KAAK,CAACJ,IAAI;IACjBO,KAAK,GAAGH,KAAK,CAACG,KAAK;IACnBT,MAAM,GAAGM,KAAK,CAACN,MAAM;IACrBJ,WAAW,GAAGU,KAAK,CAACV,WAAW;EACnC,IAAIC,QAAQ,GAAGD,WAAW,KAAK,QAAQ,GAAGI,MAAM,GAAG,CAAC;EACpD,IAAIF,YAAY;EAChB,IAAIC,QAAQ;EACZ,IAAIE,WAAW;EAEf,IAAIO,KAAK,CAACE,IAAI,CAACD,KAAK,CAAC,KAAK,IAAI,EAAE;IAC9B,OAAOZ,QAAQ;EACjB;EAEA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;IAC9B,IAAIT,IAAI,KAAK,GAAG,EAAE;MAChB,IAAIU,qBAAqB,EAAEC,WAAW;MAEtChB,QAAQ,IAAI,CAACe,qBAAqB,GAAG,CAACC,WAAW,GAAGL,KAAK,CAACE,IAAI,CAACC,CAAC,CAAC,MAAM,IAAI,IAAIE,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACC,WAAW,MAAM,IAAI,IAAIF,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC;IACpN,CAAC,MAAM;MACL,IAAIG,qBAAqB,EAAEC,YAAY;MAEvCnB,QAAQ,IAAI,CAACkB,qBAAqB,GAAG,CAACC,YAAY,GAAGR,KAAK,CAACE,IAAI,CAACC,CAAC,CAAC,MAAM,IAAI,IAAIK,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACC,YAAY,MAAM,IAAI,IAAIF,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC;IACxN;EACF;EAEA,IAAIb,IAAI,KAAK,GAAG,EAAE;IAChB,IAAIgB,sBAAsB,EAAEC,YAAY;IAExCrB,YAAY,GAAGS,QAAQ,CAACO,WAAW;IACnCf,QAAQ,GAAG,CAACmB,sBAAsB,GAAG,CAACC,YAAY,GAAGX,KAAK,CAACE,IAAI,CAACD,KAAK,CAAC,MAAM,IAAI,IAAIU,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACL,WAAW,MAAM,IAAI,IAAII,sBAAsB,KAAK,KAAK,CAAC,GAAGA,sBAAsB,GAAG,CAAC;IAC3NjB,WAAW,GAAGM,QAAQ,CAACa,UAAU;EACnC,CAAC,MAAM;IACL,IAAIC,sBAAsB,EAAEC,YAAY;IAExCxB,YAAY,GAAGS,QAAQ,CAACU,YAAY;IACpClB,QAAQ,GAAG,CAACsB,sBAAsB,GAAG,CAACC,YAAY,GAAGd,KAAK,CAACE,IAAI,CAACD,KAAK,CAAC,MAAM,IAAI,IAAIa,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACL,YAAY,MAAM,IAAI,IAAII,sBAAsB,KAAK,KAAK,CAAC,GAAGA,sBAAsB,GAAG,CAAC;IAC5NpB,WAAW,GAAGM,QAAQ,CAACgB,SAAS;EAClC;EAEA,OAAO7B,wBAAwB,CAAC;IAC9BE,WAAW,EAAEA,WAAW;IACxBC,QAAQ,EAAEA,QAAQ;IAClBC,YAAY,EAAEA,YAAY;IAC1BC,QAAQ,EAAEA,QAAQ;IAClBC,MAAM,EAAEA,MAAM;IACdC,WAAW,EAAEA,WAAW;IACxBC,IAAI,EAAEA;EACR,CAAC,CAAC;AACJ,CAAC;AACD;AACA;AACA;;AAEA,OAAO,IAAIsB,mBAAmB,GAAG,SAASA,mBAAmB,CAACjB,QAAQ,EAAEkB,OAAO,EAAEvB,IAAI,EAAE;EACrF,IAAIwB,WAAW,GAAGxB,IAAI,KAAK,GAAG,GAAG,aAAa,GAAG,YAAY;EAC7D,OAAOyB,QAAQ,CAACC,gBAAgB,CAACrB,QAAQ,CAAC,CAACmB,WAAW,CAAC,EAAE,EAAE,CAAC,GAAGC,QAAQ,CAACC,gBAAgB,CAACH,OAAO,CAAC,CAACC,WAAW,CAAC,EAAE,EAAE,CAAC;AACrH,CAAC;AACD;AACA;AACA;;AAEA,OAAO,IAAIG,WAAW,GAAG,SAASA,WAAW,CAACC,KAAK,EAAE;EACnD,IAAIvB,QAAQ,GAAGuB,KAAK,CAACvB,QAAQ;IACzBwB,GAAG,GAAGD,KAAK,CAACC,GAAG;IACf7B,IAAI,GAAG4B,KAAK,CAAC5B,IAAI;IACjB8B,QAAQ,GAAGF,KAAK,CAACE,QAAQ;IACzBC,QAAQ,GAAGH,KAAK,CAACG,QAAQ;IACzBC,cAAc,GAAGJ,KAAK,CAACI,cAAc;EAEzC,IAAIhC,IAAI,KAAK,GAAG,IAAIiC,IAAI,CAACC,GAAG,CAACL,GAAG,GAAGxB,QAAQ,CAACa,UAAU,CAAC,GAAG,CAAC,EAAE;IAC3D,IAAIY,QAAQ,EAAE;MACZxC,iBAAiB,CAACe,QAAQ,EAAEwB,GAAG,EAAEE,QAAQ,EAAEC,cAAc,CAAC;IAC5D,CAAC,MAAM;MACL3B,QAAQ,CAAC8B,QAAQ,CAAC;QAChBC,IAAI,EAAEP;MACR,CAAC,CAAC;IACJ;EACF;EAEA,IAAI7B,IAAI,KAAK,GAAG,IAAIiC,IAAI,CAACC,GAAG,CAACL,GAAG,GAAGxB,QAAQ,CAACgB,SAAS,CAAC,GAAG,CAAC,EAAE;IAC1D,IAAIS,QAAQ,EAAE;MACZvC,iBAAiB,CAACc,QAAQ,EAAEwB,GAAG,EAAEE,QAAQ,EAAEC,cAAc,CAAC;IAC5D,CAAC,MAAM;MACL3B,QAAQ,CAAC8B,QAAQ,CAAC;QAChBE,GAAG,EAAER;MACP,CAAC,CAAC;IACJ;EACF;AACF,CAAC;AAED,IAAIS,KAAK,GAAG,SAASA,KAAK,CAACC,CAAC,EAAE;EAC5B,OAAON,IAAI,CAACK,KAAK,CAACC,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG;AAClC,CAAC;AACD;AACA;AACA;AACA;;AAGA,OAAO,IAAIC,WAAW,GAAG,SAASA,WAAW,CAACC,SAAS,EAAEC,OAAO,EAAE7C,QAAQ,EAAEE,WAAW,EAAE4C,UAAU,EAAEjD,WAAW,EAAE;EAChH,IAAIkD,SAAS,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;EACrF,IAAI/C,MAAM,GAAG+C,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;;EAElF;AACF;AACA;AACA;EACE,IAAIG,SAAS,GAAGjD,WAAW,GAAG4C,UAAU;EACxC,IAAIM,YAAY,GAAGlD,WAAW,GAAG4C,UAAU,GAAG,CAAC;EAC/C,IAAIO,UAAU,GAAGR,OAAO,GAAG7C,QAAQ,GAAG,CAAC;EAEvC,IAAIH,WAAW,KAAK,QAAQ,EAAE;IAC5B,OAAO4C,KAAK,CAAC,CAACY,UAAU,GAAGD,YAAY,IAAIpD,QAAQ,CAAC;EACtD;EAEA,IAAIH,WAAW,KAAK,OAAO,EAAE;IAC3B,OAAO4C,KAAK,CAAC,CAACI,OAAO,GAAG7C,QAAQ,GAAGE,WAAW,IAAIF,QAAQ,CAAC;EAC7D;EAEA,IAAIH,WAAW,KAAK,KAAK,EAAE;IACzB,OAAO4C,KAAK,CAAC,CAACI,OAAO,IAAIC,UAAU,GAAG5C,WAAW,CAAC,IAAIF,QAAQ,CAAC;EACjE;EAEA,IAAIH,WAAW,KAAK,iBAAiB,EAAE;IACrC,IAAIyD,SAAS,GAAGrD,MAAM,GAAGD,QAAQ,GAAG+C,SAAS;IAC7C,IAAIQ,OAAO,GAAGD,SAAS,GAAGtD,QAAQ;IAClC,IAAIwD,WAAW,GAAGD,OAAO,GAAGrD,WAAW,IAAIoD,SAAS,GAAGH,SAAS;IAEhE,IAAI,CAACK,WAAW,EAAE;MAChB,IAAIT,SAAS,GAAGH,SAAS,EAAE;QACzB,OAAOH,KAAK,CAAC,CAACI,OAAO,IAAIC,UAAU,GAAG5C,WAAW,CAAC,IAAIF,QAAQ,CAAC;MACjE;MAEA,OAAOyC,KAAK,CAAC,CAACI,OAAO,GAAG7C,QAAQ,GAAGE,WAAW,IAAIF,QAAQ,CAAC;IAC7D;EACF;EAEA,OAAO,IAAI;AACb,CAAC;AACD,OAAO,SAASyD,gBAAgB,CAACC,KAAK,EAAE;EACtC,OAAOA,KAAK,CAACC,QAAQ;AACvB;AACA,IAAIC,kBAAkB,GAAG;EACvBC,CAAC,EAAE,SAASA,CAAC,CAAC/D,QAAQ,EAAE;IACtB,OAAO,aAAa,CAACgE,MAAM,CAAC,CAAChE,QAAQ,EAAE,KAAK,CAAC;EAC/C,CAAC;EACDiE,CAAC,EAAE,SAASA,CAAC,CAACjE,QAAQ,EAAE;IACtB,OAAO,aAAa,CAACgE,MAAM,CAAC,CAAChE,QAAQ,EAAE,KAAK,CAAC;EAC/C;AACF,CAAC;AACD,IAAIkE,kBAAkB,GAAG;EACvBH,CAAC,EAAE,YAAY;EACfE,CAAC,EAAE;AACL,CAAC;AACD,IAAIE,gBAAgB,GAAG;EACrBJ,CAAC,EAAE,aAAa;EAChBE,CAAC,EAAE;AACL,CAAC;AACD,IAAIG,kBAAkB,GAAG;EACvBL,CAAC,EAAE,YAAY;EACfE,CAAC,EAAE;AACL,CAAC;AAED,SAASI,iBAAiB,CAACnE,QAAQ,EAAEoE,SAAS,EAAErE,YAAY,EAAEsE,WAAW,EAAE;EACzE,IAAIC,cAAc,GAAGF,SAAS,GAAGC,WAAW,GAAGrE,QAAQ,GAAG,CAAC;EAC3D,OAAOsE,cAAc,GAAGvE,YAAY,GAAG,CAAC;AAC1C;AAEA,SAASwE,cAAc,CAACvE,QAAQ,EAAEoE,SAAS,EAAErE,YAAY,EAAEsE,WAAW,EAAE;EACtE,OAAO,CAAC,GAAGA,WAAW,GAAGD,SAAS,GAAGpE,QAAQ,GAAGD,YAAY;AAC9D;AAEA,SAASyE,oBAAoB,CAACxE,QAAQ,EAAEoE,SAAS,EAAErE,YAAY,EAAEsE,WAAW,EAAExE,WAAW,EAAE;EACzF,QAAQA,WAAW;IACjB,KAAK,OAAO;MACV;QACE,OAAOuE,SAAS;MAClB;IAEF,KAAK,KAAK;MACR;QACE,OAAOG,cAAc,CAACvE,QAAQ,EAAEoE,SAAS,EAAErE,YAAY,EAAEsE,WAAW,CAAC;MACvE;IAEF,KAAK,QAAQ;IACb,KAAK,iBAAiB,CAAC,CAAC;;IAExB;MACE,OAAOF,iBAAiB,CAACnE,QAAQ,EAAEoE,SAAS,EAAErE,YAAY,EAAEsE,WAAW,CAAC;EAAC;AAE/E;AAEA,SAASI,aAAa,CAAC3E,QAAQ,EAAE4E,SAAS,EAAE3E,YAAY,EAAEsE,WAAW,EAAE;EACrE,IAAIvE,QAAQ,GAAG,CAAC,EAAE;IAChB,OAAO,CAAC;EACV,CAAC,CAAC;;EAGF,IAAI4E,SAAS,GAAG3E,YAAY,EAAE;IAC5B,IAAI4E,SAAS,GAAGvC,IAAI,CAACC,GAAG,CAACtC,YAAY,GAAG2E,SAAS,GAAGL,WAAW,CAAC;IAEhE,OAAOvE,QAAQ,GAAG6E,SAAS,GAAG7E,QAAQ,GAAG6E,SAAS;EACpD;EAEA,IAAIC,QAAQ,GAAGF,SAAS,GAAG3E,YAAY,GAAGsE,WAAW;EAErD,IAAIvE,QAAQ,GAAG8E,QAAQ,EAAE;IACvB,OAAOA,QAAQ;EACjB;EAEA,OAAO9E,QAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAAS+E,iBAAiB,CAAC9B,SAAS,EAAErC,KAAK,EAAEoE,aAAa,EAAE;EAC1D;EACA,IAAIA,aAAa,KAAK,CAAC,EAAE;IACvB,OAAO,KAAK;EACd;EAEA,OAAO1C,IAAI,CAACC,GAAG,CAAC3B,KAAK,GAAGqC,SAAS,CAAC,KAAK+B,aAAa,GAAG,CAAC;AAC1D;AAEA,SAASC,iBAAiB,CAACC,OAAO,EAAE7C,cAAc,EAAE;EAClD,IAAI6C,OAAO,EAAE;IACXA,OAAO,CAACC,KAAK,CAACC,wBAAwB,GAAG/C,cAAc;EACzD;AACF;AAEA,SAASgD,mBAAmB,CAACH,OAAO,EAAE7E,IAAI,EAAEL,QAAQ,EAAE;EACpD,IAAIsF,SAAS,GAAGxB,kBAAkB,CAACzD,IAAI,CAAC;EACxC6E,OAAO,CAACC,KAAK,CAACI,SAAS,GAAGD,SAAS,CAACtF,QAAQ,CAAC;AAC/C;AAEA,IAAIwF,aAAa,GAAG;EAClBC,QAAQ,EAAE,MAAM;EAChBhD,IAAI,EAAE,CAAC;EACPC,GAAG,EAAE;AACP,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASgD,gBAAgB,CAAC9E,KAAK,EAAEqC,SAAS,EAAE5C,IAAI,EAAEsF,KAAK,EAAE/B,KAAK,EAAEgC,QAAQ,EAAEC,gBAAgB,EAAEC,UAAU,EAAE;EAC7G,IAAIlC,KAAK,KAAK,IAAI,IAAIgC,QAAQ,KAAK,IAAI,EAAE;IACvC;EACF;EAEA,IAAIG,SAAS,GAAG3B,kBAAkB,CAAC/D,IAAI,CAAC;EAExC,IAAIwF,gBAAgB,KAAK,KAAK,IAAIC,UAAU,KAAK,WAAW,IAAIF,QAAQ,CAACG,SAAS,CAAC,KAAK,CAAC,EAAE;IACzFH,QAAQ,CAACpD,QAAQ,CAACgD,aAAa,CAAC;EAClC;EAEA,IAAIQ,iBAAiB,GAAGpC,KAAK,CAACC,QAAQ,CAAChD,IAAI,CAACD,KAAK,CAAC;EAElD,IAAIoF,iBAAiB,KAAK,IAAI,EAAE;IAC9B;EACF;EAEA,IAAIhB,aAAa,GAAGpB,KAAK,CAACC,QAAQ,CAACV,MAAM;EACzC,IAAI8C,SAAS,GAAG/B,kBAAkB,CAAC7D,IAAI,CAAC;EACxC,IAAI6F,OAAO,GAAG/B,gBAAgB,CAAC9D,IAAI,CAAC;EACpC,IAAIJ,YAAY,GAAG2F,QAAQ,CAACM,OAAO,CAAC;EACpC,IAAItB,SAAS,GAAGhB,KAAK,CAACsC,OAAO,CAAC;EAC9B,IAAI3B,WAAW,GAAGX,KAAK,CAACqC,SAAS,CAAC;EAClC,IAAI/F,QAAQ,GAAG8F,iBAAiB,CAACE,OAAO,CAAC;EACzC,IAAI5B,SAAS,GAAG0B,iBAAiB,CAACC,SAAS,CAAC;EAC5C,IAAIE,iBAAiB,GAAGzB,oBAAoB,CAACxE,QAAQ,EAAEoE,SAAS,EAAErE,YAAY,EAAEsE,WAAW,EAAEoB,KAAK,CAAC;EACnG,IAAI3F,QAAQ,GAAG2E,aAAa,CAACwB,iBAAiB,EAAEvB,SAAS,EAAE3E,YAAY,EAAEsE,WAAW,CAAC;EAErF,IAAIuB,UAAU,KAAK,QAAQ,EAAE;IAC3BF,QAAQ,CAACpD,QAAQ,CAAC;MAChBiD,QAAQ,EAAEI,gBAAgB,GAAG,MAAM,GAAG,QAAQ;MAC9CpD,IAAI,EAAEpC,IAAI,KAAK,GAAG,GAAGL,QAAQ,GAAG,CAAC;MACjC0C,GAAG,EAAErC,IAAI,KAAK,GAAG,GAAGL,QAAQ,GAAG;IACjC,CAAC,CAAC;IACF;EACF;EAEA,IAAI6F,gBAAgB,KAAK,IAAI,IAAId,iBAAiB,CAAC9B,SAAS,EAAErC,KAAK,EAAEoE,aAAa,CAAC,KAAK,IAAI,EAAE;IAC5F;IACAC,iBAAiB,CAACrB,KAAK,EAAE,YAAY,CAAC;IACtCyB,mBAAmB,CAACzB,KAAK,EAAEvD,IAAI,EAAEL,QAAQ,CAAC;IAC1C;AACJ;AACA;AACA;;IAEIoG,UAAU,CAACnB,iBAAiB,EAAE,CAAC,EAAErB,KAAK,EAAE,EAAE,CAAC;IAC3C;EACF;EAEAyB,mBAAmB,CAACzB,KAAK,EAAEvD,IAAI,EAAEL,QAAQ,CAAC;AAC5C"},"metadata":{},"sourceType":"module","externalDependencies":[]}