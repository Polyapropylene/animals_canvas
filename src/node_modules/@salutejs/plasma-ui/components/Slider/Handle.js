"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Handle = void 0;

var _react = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/require("react"));

var _styledComponents = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/require("styled-components"));

var _reactDraggable = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/require("react-draggable"));

var _plasmaTokens = /*#__PURE__*/require("@salutejs/plasma-tokens");

var _SliderBase = /*#__PURE__*/require("./SliderBase");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var HandleStyled = /*#__PURE__*/_styledComponents["default"].div.withConfig({
  componentId: "plasma-ui__sc-76ysk-0"
})(["cursor:pointer;position:absolute;z-index:100;top:0;left:0;border-radius:50%;background-color:", ";width:", "rem;height:", "rem;border:", "rem solid ", ";background-clip:content-box;"], _plasmaTokens.white, _SliderBase.handleDiameter, _SliderBase.handleDiameter, _SliderBase.handleBorderWidth, _plasmaTokens.surfaceLiquid03);

function getValue(handleCenterXRelative, stepSize, min, max) {
  var newValue = Math.round(handleCenterXRelative / stepSize) + min;
  return Math.min(Math.max(newValue, min), max);
}

function getOffsets(ref, side) {
  if (!ref || !('current' in ref) || !ref.current || !side) {
    return [0, 0];
  }

  var size = ref.current.clientWidth - ref.current.clientLeft;

  if (side === 'left') {
    return [0, size];
  }

  if (side === 'right') {
    return [size, 0];
  }

  return [0, 0];
}

var Handle = /*#__PURE__*/_react["default"].forwardRef(function (_ref, ref) {
  var stepSize = _ref.stepSize,
      onChangeCommitted = _ref.onChangeCommitted,
      onChange = _ref.onChange,
      xPosition = _ref.xPosition,
      min = _ref.min,
      max = _ref.max,
      _ref$bounds = _ref.bounds,
      bounds = _ref$bounds === void 0 ? [] : _ref$bounds,
      zIndex = _ref.zIndex,
      disabled = _ref.disabled,
      side = _ref.side;

  var lastOnChangeValue = _react["default"].useRef(null);

  var onDrag = _react["default"].useCallback(function (_, data) {
    if (onChange) {
      var newValue = getValue(data.x, stepSize, min, max);

      if (lastOnChangeValue.current !== newValue) {
        onChange(newValue, data);
        lastOnChangeValue.current = newValue;
      }
    }
  }, [onChange, stepSize, min, max]);

  var onStop = _react["default"].useCallback(function (_, data) {
    var newValue = getValue(data.x, stepSize, min, max);
    onChangeCommitted(newValue, data);
  }, [onChangeCommitted, stepSize, min, max]);

  var _getOffsets = getOffsets(ref, side),
      _getOffsets2 = _slicedToArray(_getOffsets, 2),
      offsetLeft = _getOffsets2[0],
      offsetRight = _getOffsets2[1];

  var _bounds = _slicedToArray(bounds, 2),
      leftValueBound = _bounds[0],
      rightValueBound = _bounds[1];

  var leftPositionBound = leftValueBound ? (leftValueBound - min) * stepSize : null;
  var rightPositionBound = rightValueBound ? (rightValueBound - min) * stepSize : null;
  return /*#__PURE__*/_react["default"].createElement(_reactDraggable["default"], {
    axis: "x",
    bounds: {
      left: (leftPositionBound !== null && leftPositionBound !== void 0 ? leftPositionBound : 0) + offsetLeft,
      right: (rightPositionBound !== null && rightPositionBound !== void 0 ? rightPositionBound : stepSize * (max - min)) - offsetRight
    },
    grid: [stepSize, 1],
    onStop: onStop,
    onDrag: onDrag,
    position: typeof xPosition === 'number' ? {
      x: xPosition,
      y: 0
    } : undefined,
    disabled: disabled
  }, /*#__PURE__*/_react["default"].createElement(HandleStyled, {
    ref: ref,
    style: {
      zIndex: zIndex
    }
  }));
});

exports.Handle = Handle;