function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React from 'react';
import styled from 'styled-components';
import Draggable from 'react-draggable';
import { surfaceLiquid03, white } from '@salutejs/plasma-tokens';
import { handleDiameter, handleBorderWidth } from './SliderBase'; // TODO: https://github.com/salute-developers/plasma/issues/195

var HandleStyled = /*#__PURE__*/styled.div.withConfig({
  componentId: "plasma-ui__sc-76ysk-0"
})(["cursor:pointer;position:absolute;z-index:100;top:0;left:0;border-radius:50%;background-color:", ";width:", "rem;height:", "rem;border:", "rem solid ", ";background-clip:content-box;"], white, handleDiameter, handleDiameter, handleBorderWidth, surfaceLiquid03);

function getValue(handleCenterXRelative, stepSize, min, max) {
  var newValue = Math.round(handleCenterXRelative / stepSize) + min;
  return Math.min(Math.max(newValue, min), max);
}

function getOffsets(ref, side) {
  if (!ref || !('current' in ref) || !ref.current || !side) {
    return [0, 0];
  }

  var size = ref.current.clientWidth - ref.current.clientLeft;

  if (side === 'left') {
    return [0, size];
  }

  if (side === 'right') {
    return [size, 0];
  }

  return [0, 0];
}

export var Handle = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var stepSize = _ref.stepSize,
      onChangeCommitted = _ref.onChangeCommitted,
      onChange = _ref.onChange,
      xPosition = _ref.xPosition,
      min = _ref.min,
      max = _ref.max,
      _ref$bounds = _ref.bounds,
      bounds = _ref$bounds === void 0 ? [] : _ref$bounds,
      zIndex = _ref.zIndex,
      disabled = _ref.disabled,
      side = _ref.side;
  var lastOnChangeValue = React.useRef(null);
  var onDrag = React.useCallback(function (_, data) {
    if (onChange) {
      var newValue = getValue(data.x, stepSize, min, max);

      if (lastOnChangeValue.current !== newValue) {
        onChange(newValue, data);
        lastOnChangeValue.current = newValue;
      }
    }
  }, [onChange, stepSize, min, max]);
  var onStop = React.useCallback(function (_, data) {
    var newValue = getValue(data.x, stepSize, min, max);
    onChangeCommitted(newValue, data);
  }, [onChangeCommitted, stepSize, min, max]);

  var _getOffsets = getOffsets(ref, side),
      _getOffsets2 = _slicedToArray(_getOffsets, 2),
      offsetLeft = _getOffsets2[0],
      offsetRight = _getOffsets2[1];

  var _bounds = _slicedToArray(bounds, 2),
      leftValueBound = _bounds[0],
      rightValueBound = _bounds[1];

  var leftPositionBound = leftValueBound ? (leftValueBound - min) * stepSize : null;
  var rightPositionBound = rightValueBound ? (rightValueBound - min) * stepSize : null;
  return /*#__PURE__*/React.createElement(Draggable, {
    axis: "x",
    bounds: {
      left: (leftPositionBound !== null && leftPositionBound !== void 0 ? leftPositionBound : 0) + offsetLeft,
      right: (rightPositionBound !== null && rightPositionBound !== void 0 ? rightPositionBound : stepSize * (max - min)) - offsetRight
    },
    grid: [stepSize, 1],
    onStop: onStop,
    onDrag: onDrag,
    position: typeof xPosition === 'number' ? {
      x: xPosition,
      y: 0
    } : undefined,
    disabled: disabled
  }, /*#__PURE__*/React.createElement(HandleStyled, {
    ref: ref,
    style: {
      zIndex: zIndex
    }
  }));
});